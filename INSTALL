#!/usr/bin/env bash
#
# Dotfiles installer and uninstaller
#

# Set useful shell options.
set -Cueo pipefail

shopt -s extglob
shopt -s nullglob

readonly filepath="$(realpath "$0")"
readonly self="${filepath##*/}"
readonly parent="${filepath%/*}"

function warning () {
  if [[ -t 2 ]]; then
    local -r prefix='\033[33m'
    local -r suffix='\033[0m'
  else
    local -r prefix=
    local -r suffix=
  fi

  echo -e "${prefix}${*}${suffix}" >&2
}

function error () {
  if [[ -t 2 ]]; then
    local -r prefix='\033[31m'
    local -r suffix='\033[0m'
  else
    local -r prefix=
    local -r suffix=
  fi

  echo -e "${prefix}${*}${suffix}" >&2
}

function is_linux () {
  [[ "$OSTYPE" =~ ^linux ]]
}

function is_macos () {
  [[ "$OSTYPE" =~ ^darwin ]]
}

function has () {
  type "$1" &>/dev/null
}

function has_commands () {
  local all=0

  for cmd; do
    if ! has "$cmd"; then
      errror "'$cmd is not found on command line."
      all=1
    fi
  done

  return "$all"
}

if ! cd "$parent"; then
  error 'Fail to change directory to script parent.'
  exit 1
fi

function help () {
  echo -e -n "\
Descriptions:
  Dotfiles installer and uninstaller with extra.

Usage:
  $self <SUBCOMMAND>

Subcommands:
  init         Initialize setup
  deploy       Deploy dotfiles
  undeploy     Remove deployed dotfiles
  rust         Install rust tool chain
  haskell      Install haskell tool chain
  lscolor      Install ls color config
  python-packages
               Install python packages with pip
  haskell-packages
               Install haskell packages with cabal
  ghq-binary   Install ghq binary from GitHub release

Options:
  -h, --help   Show this messages and exit.
"
}

readonly bin_srcpath="${parent}/bin"
readonly bin_dstpath=~/bin
readonly config_srcpath="${parent}/.config"
readonly config_dstpath=~/.config
readonly home_config_srcpath="${parent}/home"
readonly home_config_dstpath=~

# List files in a directory which is specified as an argument. Each files are
# preceded by the directory path.
function list_files () {
  local src="${1%%*(/)}"

  if [[ ! -d "$src" ]]; then
    warning "$src is not directory."
    return 1
  fi

  local GLOBIGNORE="$src/*~"
  printf '%s\n' "$src"/*
}

# Make symbolik links from files in source directory to in destination
# directory.
function links () {
  local -r src_dir="${1%%*(/)}"
  local -r dst_dir="${2%%*(/)}"

  # validations
  if [[ ! "$src_dir" =~ ^/ ]]; then
    error "Source directory is not absolute path '$src_dir'"
    return 1
  fi

  if [[ ! -d "$src_dir" ]]; then
    error "No such source directory '$src_dir'"
    return 1
  fi

  if [[ ! "$dst_dir" =~ ^/ ]]; then
    error "Destination directory is not absolute path '$dst_dir'"
    return 1
  fi

  if [[ ! -d "$dst_dir" ]]; then
    error "No such destination directory '$dst_dir'"
    return 1
  fi

  list_files "$src_dir" | while read -r -d $'\n' link_src; do
    local f_base="${link_src##*/}"
    local link_dst="${dst_dir}/${f_base}"

    if [[ -a "${link_dst}" ]]; then
      warning "Skip linking from ${link_src} to ${link_dst} because ${f_base} has already existed in ${dst_dir}."
    else
      command ln -sv "$link_src" "$link_dst"
    fi
  done
}

function has_same_resolved_path () {
  local p1 p2
  p1="$(realpath "$1")"
  p2="$(realpath "$2")"

  [[ "$p1" == "$p2" ]]
}

# Remove symbolic links from destination directory.
function unlinks () {
  local -r src_dir="${1%%*(/)}"
  local -r dst_dir="${2%%*(/)}"

  # validations
  if [[ ! "$src_dir" =~ ^/ ]]; then
    error "Source directory is not absolute path '$src_dir'"
    return 1
  fi

  if [[ ! -d "$src_dir" ]]; then
    error "No such source directory '$src_dir'"
    return 1
  fi

  if [[ ! "$dst_dir" =~ ^/ ]]; then
    error "Destination directory is not absolute path '$dst_dir'"
    return 1
  fi

  if [[ ! -d "$dst_dir" ]]; then
    error "No such destination directory '$dst_dir'"
    return 1
  fi

  list_files "$src_dir" | while read -r -d $'\n' link_src; do
    local f_base="${link_src##*/}"
    local link_dst="${dst_dir}/${f_base}"

    if [[ ! -h "$link_dst" ]]; then
      warning "Skip unlinking $link_dst because no such link."
      continue
    fi

    if ! has_same_resolved_path "$link_src" "$link_dst"; then
      warning "Skip unlinking $link_dst because the link is not under control of this repository."
      continue
    fi

    command unlink "$link_dst" && echo "unlink: $link_dst"
  done
}

function deploy_bins () {
  links "$bin_srcpath" "$bin_dstpath"
}

function deploy_configs () {
  links "$config_srcpath" "$config_dstpath"
}

function deploy_home_configs () {
  links "$home_config_srcpath" "$home_config_dstpath"
}

function undeploy_bins () {
  unlinks "$bin_srcpath" "$bin_dstpath"
}

function undeploy_configs () {
  unlinks "$config_srcpath" "$config_dstpath"
}

function undeploy_home_configs () {
  unlinks "$home_config_srcpath" "$home_config_dstpath"
}

function deploy () {
  deploy_bins
  deploy_configs
  deploy_home_configs
}

function undeploy () {
  undeploy_bins
  undeploy_configs
  undeploy_home_configs
}

function init () {
  mkdir -vp \
    ~/bin \
    ~/.config \
    ~/.cache \
    ~/.local/share \
    ;
}

function rust () {
  # https://rustup.rs/
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
}

function haskell () {
  # https://www.haskell.org/ghcup/
  curl --proto '=https' --tlsv1.2 -sSf https://get-ghcup.haskell.org | sh
}

function lscolor () {
  curl -sL https://raw.githubusercontent.com/trapd00r/LS_COLORS/master/LS_COLORS > ~/.dircolors
}

function python-packages () {
  local -ar packages=(
    pipenv
    'python-language-server[all]'
    flake8
    ipdb
    tmuxp
    kaggle
    youtube-dl
    vim-vint
    # powerline-status
  )

  pip3 install --user "${packages[@]}"
}

function haskell-packages () {
  cabal install ShellCheck
  cabal install xmonad xmonad-contrib
  cabal install xmobar --flags="all_extensions"
}

function install_ghq () {
  if ! has_commands curl bsdtar grep; then
    return 1
  fi

  local zipfile

  if is_linux; then
    zipfile='ghq_linux_amd64.zip'
  elif is_macos; then
    zipfile='ghq_darwin_amd64.zip'
  else
    error 'This OS is not neither Linux nor macOS, so no prebuild binary on GitHub release.'
    return 1
  fi

  # So bad looking but for compatibility until Bash v4.2. Wanna use lastpipe
  # option.
  local asset_url
  asset_url="$( \
    curl -L -H "Accept: application/vnd.github.v3+json" 'https://api.github.com/repos/x-motemen/ghq/releases/latest' \
      | grep -E -o "https://.*${zipfile}" \
  )"

  if [[ -z "$asset_url" ]]; then
    error 'The asset url is empty.'
    return 1
  fi

  if [[ ! -d ~/bin ]]; then
    warning 'No ~/bin directory exists, so create it to deploy ghq binary.'
    mkdir ~/bin
  fi

  curl -L "$asset_url" | bsdtar -x -f - --include '*/ghq' --strip-components 1 -C ~/bin

  if [[ ! -x ~/bin/ghq ]]; then
    chmod -v +x ~/bin/ghq
  fi
}

# main

# Argument array
declare -a args=()

# Parse arguments
while (( $# )); do
  case "$1" in
    --debug )
      set -x
      shift
      ;;
    -h | --help )
      help
      exit 0
      ;;
    -* )
      error "Invalid option '$1'"
      exit 1
      ;;
    * )
      args+=("$1")
      shift
      ;;
  esac
done

if (( ! $# )); then
  help
  exit 0
fi

case "${args[0]}" in
  init )
    init
    ;;
  deploy )
    deploy
    ;;
  undeploy )
    undeploy
    ;;
  rust )
    rust
    ;;
  haskell )
    haskell
    ;;
  lscolor )
    lscolor
    ;;
  python-packages )
    python-packages
    ;;
  haskell-packages )
    haskell-packages
    ;;
  ghq-binary )
    install_ghq
    ;;
  * )
    error "Invalid subcommand '${args[0]}'"
    exit 1
    ;;
esac
